{"version":3,"sources":["project/tutsnotes.cljs"],"mappings":"","names":[],"sourcesContent":["(ns project.tutsnotes\n  (:require [project.reframeevents]\n            [project.config])\n  (:require-macros [project.macros]))\n\n;; (defn my-reducer\n;;   [acc curr]\n;;   (print \"accumulator\" acc \"current value in list..\" curr)\n;;   (set (conj acc curr)))\n\n;; (def removed-dups (let [intermediate-value (reduce my-reducer [{:b \"some val\"} {:c \"other val\"}] [{:d \"my val\"}\n;;                                                                                                   {:e \"my e\"}\n;;                                                                                                   {:e \"my e\"}\n;;                                                                                                   {:d \"a value\"}\n;;                                                                                                   {:e \"my e\"}\n;;                                                                                                   {:e \"my e\"}\n;;                                                                                                   {:f \"an eff\"}])]\n;;                     (print \"getting :b out of a set \\\"{:b \\\"some val\\\"}\\\" => \" (get-in intermediate-value [{:b \"some val\"} :b]))\n;;                     (into {} intermediate-value)))\n\n;; (print \"used \\\"into\\\" to move intermediate-value values back into an actual map\"\n;;        removed-dups\n;;        (:f removed-dups))\n\n;; (print (if (= (:b (get removed-dups 0)) \"some val\")\n;;          \"true, we are able to retrieve the value of key :b\"\n;;          \"false, :b does not exit or contain a value\"))\n\n;; -- example from braveclojure.com\n;; (reduce (fn [new-map [key val]]\n;;           (if (> val 4)\n;;             (assoc new-map key val) ;; return the supplied map argument with new values inserted\n;;             new-map))               ;; be sure to return the map argument as-is without the update\n;;         {}\n;;         {:human 4.1\n;;          :critter 3.9})\n\n; => {:human 4.1}\n\n\n;; (defn map-reducer\n;;   \"Plain map reducer function that will insert a key if the val is greater than 10\"\n;;   [new-map [k v]]\n;;   (if (> v 10) (assoc new-map k v) new-map))\n\n;; (defn assoc-reducer-factory-func\n;;   \"Reducer factory function for adding a key if the value is >= than the supplied limit -- basically an implementation of filter\"\n;;   [gtlt limit]\n;;   (fn [new-map [k v]]\n;;     (if (gtlt v limit)\n;;       (do\n;;         (print {k v} \"key value meets criteria\")\n;;         (assoc new-map k v))\n;;       (do\n;;         (print {k v} \"key value does not meet conditions\")\n;;         new-map))))\n\n;; (def assoc-reduce9 (assoc-reducer-factory-func <= 4)) ;; add key only if value meets criteria\n\n;; (def reduced-values (reduce assoc-reduce9 {} {:some-val 10 :other-val 20 :low-val 4 :low-low 1 :new-val 32}))\n;; (print \"Reduced values that are greater than 9: \" reduced-values)\n\n;; (print \"This output is printing from the project.tutsnotes namespace -- just testing out various clojure functions\")\n\n;; (def some-keys {1 \"one\"\n;;                 2 \"three\"\n;;                 \"three\" 3\n;;                 \"fo\" \"four\"\n;;                 :5 5})\n\n;; (print \"keys can be anything\" (get some-keys \"three\") (:5 some-keys) (get some-keys \"fo\"))\n;; (print \"..but you'll need to access them using \\\"get\\\"\")\n\n;; (def bayo (map identity {:name \"Bayonetta\" :skills [\"breakdancing\" \"killing angels\"]}))\n;; (print \"looks as if the \\\"identity\\\" function just plain returns each element\")\n;; (print \"vec: \" bayo, (second (second bayo)))\n;; (print \"map: \"\n;;        (into {} bayo)\n;;        (second (second (into {} bayo))))\n\n;; (def food-list (into [] (map identity [:chicken-breast :oil :herbs])))\n;; (print\n;;  food-list\n;;  \"  first item in list:  \"\n;;  (first food-list))\n\n;; (def coffee-coffee-coffee\n;;   (into {} (map identity {:pod1 :mexican\n;;                           :pod2 :columbian\n;;                           :pod3 :italian})))\n;; (def coffees-as-set (into #{} (map #(second %) coffee-coffee-coffee)))\n\n;; (print\n;;  coffee-coffee-coffee\n;;  \"  value of :pod2 key in coffees:  \"\n;;  (:pod2 coffee-coffee-coffee)\n;;  \"  does :pod2 == :columbian?  \" (= :columbian (:pod2 coffee-coffee-coffee))\n;;  \"  does :pod2 == \\\"columbian\\\"?  \" (= \"columbian\" (:pod2 coffee-coffee-coffee)))\n\n;; (def answers {:true \"Yes! Right this way\" :false \"Sorry sir, we do not have that one\"})\n;; (print\n;;  \"coffee-set: \" coffees-as-set\n;;  \"  -Do you have mexican coffee?  \" (if (some? (:mexican coffees-as-set)) (:true answers) (:false answers))\n;;  \"  -What about ethiopian?  \" (if (some? (:ethiopian coffees-as-set)) (:true answers) (:false answers)))\n\n;; (def add-air\n;;   (partial conj [\"air\"]))\n\n;; (print\n;;  (conj [\"air\"] \"water\" \"fire\")\n;;  (add-air \"heat\" \"liquid\"))\n\n;; (def my-comp1 (comp inc *))\n;; (def my-comp2 (comp #(map :name %) #(map :key %)))\n;; (print\n;;  \"some comp function compositiond\"\n;;  (my-comp1 2 2)\n;;  (re-frame.core/dispatch [:get-players project.config/api-creds]))\n\n;; (my-comp2\n;;  (js/setTimeout\n;;   (fn [] (let [players @(re-frame.core/subscribe [:players])]\n;;            (print\n;;             \"Getting character names map from composed functions: \"\n;;             (my-comp2 players)))) 1000))\n\n;; (my-comp2\n;;  (js/setTimeout\n;;   (fn [] (let [players @(re-frame.core/subscribe [:players])]\n;;            (print\n;;             \"Getting character names map from composed functions: \"\n;;             (-> [\"just print this \"]\n;;                 (conj \"and this other thing.\")\n;;                 (clojure.string/join)\n;;                 (print))\n;;             (->> players\n;;                  (map :key)\n;;                  (map :name)\n;;                  (vec)\n;;                  (print \"Char. list as vec: \"))))) 1000))\n\n;; (print\n;;  \"Calling \\\"update\\\" function, new value: \"\n;;  (update\n;;   {:location \"Japan\"}\n;;   :location\n;;   #(if (= % \"Japan\") \"Tokyo\" \"Paris\"))\n;;  \"\\\"(assoc)\\\" looks to be the more common method, \\\"(update)\\\" requires a function, but would be good for calculated values: \"\n;;  (assoc {:location \"Japan\"} :location \"London\"))\n\n;; (project.macros/reorder (1 + 3))\n\n;; (print\n;;  (list\n;;   + 1 2)\n;;  (macroexpand\n;;   '(project.macros/reorder (1 + 2))))\n\n\n"]}